\documentclass[a4paper,12pt]{article}
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{definition}{Definicija}

\theoremstyle{remark}
\newtheorem*{remark}{Opomba}

\geometry{margin=2.5cm}
\setlength{\parskip}{0.8em}
\setlength{\parindent}{0pt}

\begin{document}

    \begin{center}
    \Large\textbf{Kratko poročilo – projektna naloga}\\[4pt]
    \large \textit{Skupina 18: Število podpoti pri grafih z danim ciklomatskim številom}
    \end{center}

    \section*{Uvod}

        V projektu obravnavamo \emph{povezane} grafe $G = (V, E)$, za katere je definirano \emph{ciklomatsko število}
        \[
        \mu(G) = |E| - |V| + 1.
        \]
        To število pove, koliko neodvisnih ciklov vsebuje graf oziroma koliko povezav bi morali odstraniti, da bi dobili gozd.

        \textbf{CILJ NALOGE}: raziskati, kako se obnaša \emph{število podpoti in geodetskih podpoti grafa}, torej število vseh enostavnih poti (vključno s potmi dolžine 0), pri grafih z danim ciklomatičnim številom.
        Zanima nas, kateri grafi imajo za dano število vozlišč $|V| = n$ in dano ciklomatsko število $ \mu = k$ najmanjše oziroma največje število podpoti.

    \section*{Teoretično ozadje}

        \begin{definition}[Podpot]
            Naj bo $G = (V, E)$ povezan graf in $P = v_1 v_2 \dots v_k$ pot v grafu $G$. 
            \emph{Podpot} grafa $G$ je vsaka zaporedna podzaporedje oglišč te poti, torej vsaka pot oblike
            \[
            v_i v_{i+1} \dots v_j, \quad \text{kjer } 1 \le i < j \le k.
            \]
            Subpath number $p_n(G)$ štejemo kot skupno število vseh enostavnih poti v grafu, pri čemer se šteje tudi vsako vozlišče kot pot dolžine 0.
        \end{definition}
        \smallskip

        \begin{definition}[Geodetsko število]
            Naj bo $G = (V,E)$ povezan graf. 
            \emph{Geodetsko število podpoti} $gp_n(G)$,
            definiramo kot skupno število vseh geodetskih enostavnih poti v grafu.
            Za vsaka dva vozlišča $u, v \in V(G)$ označimo z $d(u,v)$ razdaljo med njima,
            z $\sigma^*(u,v)$ pa število vseh enostavnih $u$--$v$ poti dolžine $d(u,v)$.
            Tedaj je
            \[
            gp_n(G) = \sum_{u,v \in V(G)} \sigma^*(u,v).
            \]
            Vračunane so tudi poti dolžine $0$, torej $u=v$.
            Geodetsko število podpoti tako meri, koliko najkrajših enostavnih poti vsebuje graf.
        \end{definition}

        \textbf{Kaktusni graf} je graf, v katerem se poljubna dva cikla stikata v največ enem vozlišču. 
        To pomeni, da se cikli lahko dotikajo, vendar se ne prekrivajo.

        \medskip
        \textbf{Graf PTC(n,k)} (angl.~\emph{Pseudo Triangle Chain}), slovensko psevdotrikotna veriga, 
        je poseben primer kaktusnega grafa, v katerem so vsi cikli trikotniki, povezani v verigo, 
        in dosega največje možno število podpoti med vsemi takšnimi grafi.
        Zato se v projektu pogosto uporabi kot osnovni primer (tj. zgornja meja) 
        za primerjavo z drugimi grafi, ki imajo enako ciklomatično število~$\mu(G)$.

        \bigskip
            Graf $PTC(n,k)$ ima naslednje lastnosti:
        \begin{itemize}
            \item je kaktusni graf z $n$ vozlišči in $k$ cikli;
            \item vsak notranji cikel je trikotnik;
            \item cikli so med seboj povezani v verigo (en za drugim);
            \item prvi in zadnji cikel se lahko rahlo razlikujeta po velikosti (imata lahko 4 vozlišča namesto 3);
            \item vsi cikli se stikajo v natanko enem vozlišču, zato graf tvori verižno strukturo.
        \end{itemize}

        \textbf{Izrek} (Knor, 2025) 
        Graf $PTC(n, k)$ enolično maksimizira število podpoti med vsemi kaktusnimi grafi z $n$ vozlišči in $k \ge 2$ cikli.

        \textbf{Iz literature (Knor, 2025):} za kaktusne grafe veljajo naslednji ekstremni primeri
        \begin{itemize}
            \item maksimalni $p_n(G)$ doseže t.i. \emph{pseudo triangle chain}, kjer so vsi notranji cikli trikotniki, oba končna pa se razlikujeta največ za eno vozlišče;
            \item minimalni $p_n(G)$ doseže graf, kjer so vsi cikli \emph{end-trikotniki}, torej vsak trikotnik deli največ eno skupno vozlišče z ostalim grafom.
        \end{itemize}


    \section*{Plan dela}
        Projektno nalogo bova ločila na dva dela. \\
        \textbf{1. Analiza za majhne grafe.}  
        V okolju SageMath bomo s pomočjo funkcije \emph{geng} generirali vse povezane grafe z števili vozlišč $n \le 8$ in za vsak graf izračunali:
        $|V|, |E|, \mu(G) \text{ in }p_n(G),$ \\
        $gp_n(G).$
        Pri majhnih grafih bomo $p_n(G)$ izračunali z iskanjem vseh enostavnih poti med pari vozlišč.
        Ker SageMath ne vsebuje vgrajene funkcije za štetje vseh enostavnih poti,
        smo uporabili rekurzivni pristop. Funkcija \texttt{all\_simple\_paths(G, start, end)}
        poišče vse poti med vozliščema \texttt{start} in \texttt{end}, tako da
        postopno obiskuje sosednja vozlišča, pri čemer se izogiba že obiskanih točk.
        Za vsak par vozlišč $(u, v)$ se nato prešteje število poti in sešteje.
        Na podlagi rezultatov bomo določili grafe, ki imajo minimalni in maksimalni $p_n(G)$ pri enakem $\mu(G)$ ter preverili, ali so ti grafi kaktusnega tipa. 

        \textbf{2. Analiza za večje grafe.}  
        Za grafe z več kot osmimi vozlišči bomo uporabili metodo simuliranega ohlajanja, saj popolna
        generacija vseh neizomorfnih grafov pri tej velikosti postane računsko neizvedljiva.
        Za dani vrednosti $n$ in $\mu(G)=k$ bomo najprej ustvarili povezani graf z $n$ 
        vozlišči in točno $m=n-1+k$ povezavami, za katerega si mislimo da je podoben optimalnemu. Ta graf bo začetno stanje algoritma. 
        V vsakem koraku bomo izvedli majhno lokalno spremembo grafa (t.i.\ \emph{edge swap}), pri kateri
        odstranimo en obstoječi rob in ga nadomestimo z novim, tako da ohranimo število povezav in 
        s tem tudi ciklomatsko število. Novo stanje sprejmemo vedno, kadar se vrednost $p_n(G)$ izboljša. 
        Če se vrednost poslabša, takšno stanje sprejmemo le z verjetnostjo 
        $e^{(\Delta/T)}$, kjer je $\Delta$ razlika med novim in trenutnim stanjem, 
        $T$ pa trenutna temperatura. Pri višjih temperaturah algoritem pogosteje 
        sprejema slabše korake, kar mu omogoča izogibanje lokalnim optimumom. 
        Ko temperaturo postopoma znižujemo po pravilu $T_{k+1} = \alpha T_k$, 
        postane algoritem vedno bolj "konservativen" in sprejema skoraj izključno 
        korake, ki izboljšajo rezultat. Po koncu iteracij kot končno rešitev vzamemo 
        tisti graf, ki je med izvajanjem dosegel največjo (oziroma najmanjšo) 
        vrednost $p_n(G)$, ter ga primerjamo z znanimi ekstremnimi kaktusnimi 
        grafi za iste vrednosti $n$ in $\mu(G)$.

    \section*{Pričakovani rezultati in hipoteze}

        Pričakujemo, da bo vrednost $p_n(G)$ najnižja pri drevesih in bo naraščala z večanjem
        ciklomatskega števila $\mu(G)$, saj dodatni cikli omogočajo več različnih enostavnih poti
        med pari vozlišč. Na podlagi znane literature o kaktusnih grafih domnevamo, da bo
        minimalni $p_n(G)$ dosežen pri zaporedno povezanih ciklih, kjer
        so cikli razporejeni v verigo in tako le lokalno povečujejo število poti.
        Največji $p_n(G)$ pa pričakujemo pri strukturi, kjer imajo vsi cikli skupno vozlišče,
        saj takšna razporeditev ustvarja veliko število alternativnih poti
        prek centralnega vozlišča.

        Pri večjih grafih, kjer vseh možnosti ne moremo več izračunati, pričakujemo pojav
        lokalnih ekstremov. Do njih pogosto pride takrat, ko se cikli v grafu prekrivajo
        ali si delijo vozlišča, zaradi česar dodatne povezave ne prinesejo več veliko novih
        enostavnih poti. V takih primerih $p_n(G)$ raste zelo počasi, čeprav ima graf več
        povezav. To želimo natančneje raziskati s pomočjo simuliranega ohlajanja, ki nam
        lahko pomaga poiskati te lokalne maksimume in minimume pri večjih grafih.

\end{document}
